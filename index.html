<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<title>Earthquakes JP</title>

<!-- ========================
     STYLE VISUEL (CSS)
========================= -->
<style>
  body{
    margin:0;
    font-family:Arial, sans-serif;
    background:#0f1115;
    color:white;
  }

  /* layout gauche = carte / droite = liste */
  .app{
    display:flex;
    height:100vh;
  }

  .left{
    flex:3;
    padding:15px;
    border-right:1px solid #333;
    box-sizing:border-box;
  }

  .right{
    flex:2;
    overflow:auto;
    padding:15px;
    box-sizing:border-box;
  }

  /* card s√©isme */
  .item{
    border:1px solid #333;
    padding:12px;
    margin-bottom:12px;
    border-radius:12px;
    cursor:pointer;
    background:#141821;
  }

  .item:hover{
    border-color:#555;
  }

  .item.selected{
    border-color:#7aa2ff;
  }
	
  .muted{
    color:#aaa;
    font-size:12px;
  }

  @media (max-width: 900px){
    .app{ flex-direction:column; }
    .left{ border-right:none; border-bottom:1px solid #333; }
  }

	/* =========================
   Cards compactes
========================= */

.item{
  padding:10px 12px;
  border-radius:12px;
  display:flex;
  flex-direction:column;
  gap:4px;                /* r√©duit l‚Äôespace vertical */
  background:#141821;
}

/* Ligne 1 */
.cardRow1{
  display:flex;
  align-items:center;
  gap:8px;
  font-size:13px;
}

/* Ligne 2 (date) */
.cardRow2{
  font-size:11px;
  color:#9aa1b3;
}

/* Ligne 3 (region) */
.cardRow3{
  font-size:13px;
  font-weight:600;
  color:#e3e7f2;
}

/* Badge compact */
.badge{
  padding:2px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.08);
  background:rgba(255,255,255,0.04);
  font-size:11px;
}

/* Petit point couleur */
.dotInt{
  width:8px;
  height:8px;
  border-radius:50%;
  flex:0 0 8px;
}

.uiEn{
  font-size:11px;
  color:#9aa1b3;
  margin-left:6px;
}

/* Zone selected fixe pour √©viter les sauts */
#selected{
  height: 150px;        /* hauteur FIXE */
  overflow: hidden;     /* √©vite le resize */
  padding: 10px;
  border: 1px solid #222;
  border-radius: 12px;
  background: rgba(255,255,255,0.03);
}

/* Tabs */
.tabs{
  display:flex;
  gap:10px;
  margin-top: 12px;
}
.tab{
  background:#141821;
  border:1px solid #2a2f3a;
  color:#ddd;
  padding:8px 12px;
  border-radius:12px;
  cursor:pointer;
  font-size:13px;
}
.tab.active{
  border-color:#7aa2ff;
}

.tabPage{ display:none; }
.tabPage.active{ display:block; }

/* Grille des pr√©fectures */
.prefGrid{
  column-count: 3;      /* nombre de colonnes */
  column-gap: 16px;
}
@media (min-width: 1100px){
  .prefGrid{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
}

.regionEn{
  margin-left:6px;
  font-size:11px;
  color:#9aa1b3;
  font-weight:400;
}

.prefCard{
  border:1px solid #2a2f3a;
  border-radius:12px;
  padding:10px;
  background: rgba(255,255,255,0.03);
  break-inside: avoid; 
  margin-bottom:16px;    
}

.prefHeader{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  padding-bottom:8px;
  border-bottom:1px solid rgba(255,255,255,0.06);
  margin-bottom:8px;
}

.prefName{
  font-weight:700;
  color:#fff;
  font-size:13px;
}

.prefMeta{
  color:#aaa;
  font-size:12px;
  white-space:nowrap;
}

.cityRow{
  display:flex;
  justify-content:space-between;
  gap:10px;
  padding:6px 0;
  border-bottom:1px solid rgba(255,255,255,0.06);
  font-size:12px;
}
.cityRow:last-child{ border-bottom:none; }

.cityLeft{ color:#ddd; }
.cityRight{ color:#aaa; white-space:nowrap; }

.badge{
  display:inline-block;
  padding:2px 8px;
  border:1px solid #2a2f3a;
  border-radius:999px;
  font-size:11px;
  color:#ddd;
  margin-right:6px;
}

.cardRow3 .muted{
  font-size:11px;
  color:#9aa1b3;
  margin-left:6px;
}

/* Selected panel typography */
#selected .selTitle{
  font-size:16px;
  font-weight:700;
  color:#fff;
}

#selected .selSub{
  margin-top:2px;
  font-size:12px;
  color:#9aa1b3;
}

#selected .selMeta{
  margin-top:6px;
  font-size:12px;
  color:#b6bcc8;
}

#selected .selBadges{
  margin-top:10px;
  display:flex;
  flex-wrap:wrap;
  gap:10px;
}

#selected .selBadge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:5px 10px;           /* plus grand */
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.05);
  font-size:13px;             /* plus grand */
  font-weight:600;
  color:#e3e7f2;
}

#selected .selBadgeStrong{
  font-size:14px;
  padding:6px 12px;
}

#selected .selBadgeMax{
  border:none;                /* on laisse la couleur faire le job */
}

#selected .selTsunamiLong{
  margin-top:10px;
  font-size:12px;
  color:#b6bcc8;
  line-height:1.35;
}

.legend{
  position:absolute;
  left: 24px;
  bottom: 24px;
  z-index: 1200;
  background: rgba(15,17,21,0.85);
  border: 1px solid #2a2f3a;
  border-radius: 12px;
  padding: 10px 12px;
  backdrop-filter: blur(8px);
  color:#ddd;
  font-size: 12px;
}

.legendTitle{
  font-weight: 700;
  margin-bottom: 8px;
  color:#fff;
}

.legendRow{
  display:flex;
  align-items:center;
  gap: 8px;
  flex-wrap: wrap;
}

.dot{
  width: 14px;
  height: 14px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.55);
  display:inline-block;
}

.lbl{
  margin-right: 6px;
  color:#cfd3dc;
  font-size: 12px;
}

.xmark{
  width: 14px;
  height: 14px;
  position: relative;
  display:inline-block;
}
.xmark::before,
.xmark::after{
  content:"";
  position:absolute;
  left:6px;
  top:0px;
  width:2px;
  height:14px;
  background:#ff2d2d;
}
.xmark::before{ transform: rotate(45deg); }
.xmark::after{ transform: rotate(-45deg); }

/* Ic√¥ne √©picentre sur la carte (identique √† la l√©gende) */
.epiMarker{
  width:18px;
  height:18px;
  position:relative;
}
.epiMarker::before,
.epiMarker::after{
  content:"";
  position:absolute;
  left:8px;
  top:0px;
  width:2px;
  height:18px;
  background:#ff2d2d;
}
.epiMarker::before{ transform: rotate(45deg); }
.epiMarker::after{ transform: rotate(-45deg); }

/* m√™mes couleurs que ton intensityColor() */
.int1{ background:#ffffff; }
.int2{ background:#00e5ff; }
.int3{ background:#1976ff; }
.int4{ background:#fff176; }
.int5m{ background:#ffd54f; }
.int5p{ background:#ffb300; }
.int6m{ background:#ff7043; }
.int6p{ background:#ff1744; }
.int7{ background:#ff00c8; }

#tabMap{ position: relative; }

@media (max-width:1200px){
  .prefGrid{ column-count:2; }
}

@media (max-width:700px){
  .prefGrid{ column-count:1; }
}

#selected .metricsLine{
  margin-top:10px;
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  column-gap:14px;
  row-gap:6px;
}

#selected .metric{
  display:flex;
  flex-direction:column;
  gap:2px;
}

#selected .metric .jp{
  font-size:13px;
  font-weight:800;
  color:#e3e7f2;
  line-height:1.1;
  display:flex;
  align-items:center;
  gap:8px;
}

#selected .metric .en{
  font-size:10px;
  color:#9aa1b3;
  line-height:1.1;
}

/* s√©parateur simple */
#selected .sep{
  color:#5a6272;
  font-size:13px;
  line-height:1.1;
  padding-top:1px; /* aligne avec le JP */
  user-select:none;
}
	
.intDot{
  width:10px;
  height:10px;
  border-radius:50%;
  display:inline-block;
  flex:0 0 10px;
}

</style>
</head>

<body>

<!-- ========================
     STRUCTURE HTML
========================= -->
<div class="app">

  <!-- ZONE CARTE (placeholder pour l'instant) -->
  <div class="left">
    <h2 style="margin:0 0 10px 0;">Earthquakes JP</h2>

<div id="selected" class="muted">Chargement‚Ä¶</div>

<button id="tabBtnMap" class="tab active" type="button">Âú∞Âõ≥ <span class="uiEn">Map</span></button>
<button id="tabBtnCities" class="tab" type="button">ÂêÑÂú∞„ÅÆÈúáÂ∫¶ <span class="uiEn">Affected Areas</span></button>

<div id="tabMap" class="tabPage active">
  <div id="map" style="margin-top:12px; height:70vh; border-radius:12px;"></div>
	<div id="legend" class="legend">
  <div class="legendTitle">ÈúáÂ∫¶ <span class="uiEn">Seismic intensity</span></div>
  <div class="legendRow">
    <span class="dot int7"></span><span class="lbl">7</span>
    <span class="dot int6p"></span><span class="lbl">6+</span>
    <span class="dot int6m"></span><span class="lbl">6-</span>
    <span class="dot int5p"></span><span class="lbl">5+</span>
    <span class="dot int5m"></span><span class="lbl">5-</span>
    <span class="dot int4"></span><span class="lbl">4</span>
    <span class="dot int3"></span><span class="lbl">3</span>
    <span class="dot int2"></span><span class="lbl">2</span>
    <span class="dot int1"></span><span class="lbl">1</span>
    <span class="xmark"></span><span class="lbl">ÈúáÊ∫ê <span class="uiEn">epicenter</span></span>
  </div>
</div>
</div>

<div id="tabCities" class="tabPage">
  <div id="citiesSummary" class="muted" style="margin-top:12px;"></div>
  <div id="citiesGrid" class="prefGrid" style="margin-top:12px;"></div>
</div>
  </div>

  <!-- LISTE DES S√âISMES -->
  <div class="right">
    <h2 style="margin:0 0 10px 0;">30 derniers s√©ismes</h2>
    <div id="list"></div>
  </div>

</div>

<!-- ========================
     SCRIPT JAVASCRIPT
========================= -->
<script>
let selectedId = null;
let epicenterMarker = null;
const detailCache = new Map();

async function getDetail(url){
  if(detailCache.has(url)) return detailCache.get(url);

  const r = await fetch(url);
  if(!r.ok) throw new Error("HTTP " + r.status);

  const j = await r.json();
  detailCache.set(url, j);
  return j;
}

function setLayerDimmed(isDimmed){
  const el = document.getElementById("map");
  el.style.opacity = isDimmed ? "0.75" : "1";
  el.style.transition = "opacity 150ms ease";
}

let stationMarkers = [];

function stationRadiusForZoom(z){
  if (z <= 5) return 3;
  if (z <= 6) return 4;
  if (z <= 7) return 5;
  if (z <= 9) return 6;
  return 7;
}

function updateStationRadii(){
  const r = stationRadiusForZoom(map.getZoom());
  for (const m of stationMarkers) m.setRadius(r);
}

const map = L.map("map", { preferCanvas: true }).setView([36.2, 138.2], 5);
map.on("zoomend", updateStationRadii);
const quakeLayer = L.featureGroup().addTo(map);

// Fond clair japonais (GSI Pale)
const baseMap = L.tileLayer(
  "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png",
  {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: 'abcd',
	maxZoom: 20
  }
).addTo(map);


L.tileLayer(
  "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}{r}.png",
  {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: "abcd",
    maxZoom: 20
  }
).addTo(map);


document.getElementById("tabBtnMap").onclick = () => setActiveTab("map");
document.getElementById("tabBtnCities").onclick = () => {
  setActiveTab("cities");
  renderCitiesTab(lastDetail);
};

// √©tat initial
renderCitiesTab(null);

function fmtTime(s){
  try { return new Date(s).toLocaleString(); } catch { return s; }
}
/*
  Formate une date ISO en texte lisible.
*/
function fmtShort(s){
  const d = new Date(s);
  return d.toLocaleString(undefined,{
    day:"2-digit",
    month:"short",
    hour:"2-digit",
    minute:"2-digit"
  });
}
/*
  Compte les stations dans TON JSON JMA:
  detail.Body.Intensity.Observation.Pref[].Area[].City[].IntensityStation[]
*/
function countStations(detail){
  const prefs = detail?.Body?.Intensity?.Observation?.Pref || [];
  let count = 0;

  for (const pref of prefs) {
    for (const area of (pref.Area || [])) {
      for (const city of (area.City || [])) {
        count += (city.IntensityStation || []).length;
      }
    }
  }
  return count;
}

function buildCityPoints(detail){
  const prefs = detail?.Body?.Intensity?.Observation?.Pref || [];
  const cities = [];

  for (const pref of prefs) {
    for (const area of (pref.Area || [])) {
      for (const city of (area.City || [])) {
        const st = (city.IntensityStation || [])[0];
        const lat = st?.latlon?.lat;
        const lon = st?.latlon?.lon;

        if (typeof lat === "number" && typeof lon === "number") {
          cities.push({
            name: city.Name,
            code: city.Code,
            intensity: city.MaxInt,
            lat, lon
          });
        }
      }
    }
  }
  return cities;
}

/*
  Compte les stations qui ont des coordonn√©es lat/lon.
*/
function countLatLon(detail){
  const prefs = detail?.Body?.Intensity?.Observation?.Pref || [];
  let count = 0;

  for (const pref of prefs) {
    for (const area of (pref.Area || [])) {
      for (const city of (area.City || [])) {
        for (const st of (city.IntensityStation || [])) {
          if (st.latlon && typeof st.latlon.lat === "number" && typeof st.latlon.lon === "number") {
            count++;
          }
        }
      }
    }
  }
  return count;
}

/*
  Charge events.json et affiche la liste.
*/

function updateSelectionUI(){
  document.querySelectorAll(".item").forEach(el=>{
    el.classList.remove("selected");
  });
}

function showStations(detailData){

  stationMarkers = [];

  const prefs = detailData?.Body?.Intensity?.Observation?.Pref || [];
  let count = 0;

  const r = stationRadiusForZoom(map.getZoom());

  prefs.forEach(pref=>{
    pref.Area?.forEach(area=>{
      area.City?.forEach(city=>{
        city.IntensityStation?.forEach(station=>{

          const lat = station?.latlon?.lat;
          const lon = station?.latlon?.lon;
          if (typeof lat !== "number" || typeof lon !== "number") return;

          const intVal = normalizeIntensity(station?.Int);
          const color = intensityColor(intVal);

          const jp = station?.Name || "";
          const en = station?.enName || "";

          const marker = L.circleMarker([lat, lon], {
            radius: r,
            color: "#111",        // contour sombre
            weight: 1,
            fillColor: color,
            fillOpacity: 0.95
          });

          // Label simple (au survol)
          marker.bindTooltip(
            `${jp}${en ? " (" + en + ")" : ""} ‚Ä¢ Int ${intVal}`,
            { direction: "top", opacity: 0.95, sticky: true }
          );

          // Popup plus d√©taill√© (au clic)
          marker.bindPopup(`
            <div style="font-size:13px;line-height:1.3">
              <b>${jp}${en ? " ("+en+")" : ""}</b><br>
              Intensit√©: <b>${intVal}</b><br>
              ${lat.toFixed(3)}, ${lon.toFixed(3)}
            </div>
          `);

          marker.addTo(quakeLayer);
          stationMarkers.push(marker);
          count++;
        });
      });
    });
  });

  // s'assure que le rayon est coh√©rent (au cas o√π)
  updateStationRadii();

  console.log("Stations affich√©es:", count);
}

function parseJmaCoordinateFull(coordStr){
  // Exemples:
  // "+35.4+140.5-30000/"  => lat 35.4, lon 140.5, depth 30000 (m)
  // "+40.7+140.5-10000/"  => depth 10000 (m)
  if (!coordStr || typeof coordStr !== "string") return null;

  // Capture: lat, lon, depth (optionnel)
  const m = coordStr.match(/([+-]\d+(?:\.\d+)?)([+-]\d+(?:\.\d+)?)([+-]\d+(?:\.\d+)?)?/);
  if (!m) return null;

  const lat = Number(m[1]);
  const lon = Number(m[2]);
  if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

  let depthKm = null;
  if (m[3] != null) {
    const depthRaw = Number(m[3]); // souvent n√©gatif
    if (Number.isFinite(depthRaw)) {
      const meters = Math.abs(depthRaw);
      depthKm = meters >= 1000 ? meters / 1000 : meters; // s√©curit√©
    }
  }

  return { lat, lon, depthKm };
}

function crossIcon(){
  // petite croix rouge en HTML (pas d'image)
  return L.divIcon({
    className: "",
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    html: `
      <div style="
        position:relative;
        width:20px;height:20px;
      ">
        <div style="position:absolute;left:9px;top:0;width:2px;height:20px;background:#ff2d2d;"></div>
        <div style="position:absolute;left:0;top:9px;width:20px;height:2px;background:#ff2d2d;"></div>
        <div style="position:absolute;left:8px;top:8px;width:4px;height:4px;background:#ff2d2d;border-radius:50%;"></div>
      </div>
    `
  });
}

function showEpicenter(detail){
  const coordStr = detail?.Body?.Earthquake?.Hypocenter?.Area?.Coordinate;
  const p = parseJmaCoordinateFull(coordStr);
  if (!p) return null;

  // enlever l'ancien
  if (epicenterMarker) {
    map.removeLayer(epicenterMarker);
    epicenterMarker = null;
  }

  epicenterMarker = L.marker([p.lat, p.lon], { icon: epicenterIcon() }).addTo(map);
  epicenterMarker.bindPopup(`<b>√âpicentre</b><br>${p.lat.toFixed(3)}, ${p.lon.toFixed(3)}`);

  return p;
}

	function intensityColor(intStr){
  const v = String(intStr || "").trim();
  // Palette proche JMA (approx)
  const map = {
    "1":  "#ffffff",
    "2":  "#00e5ff",
    "3":  "#1976ff",
    "4":  "#fff176",
    "5-": "#ffd54f",
    "5+": "#ffb300",
    "6-": "#ff7043",
    "6+": "#ff1744",
    "7":  "#ff00c8"
  };
  return map[v] || "#aaaaaa";
}

function normalizeIntensity(v){
  // certaines valeurs peuvent √™tre "5Âº±" etc selon sources
  const s = String(v || "").trim();
  if (s === "5Âº±") return "5-";
  if (s === "5Âº∑") return "5+";
  if (s === "6Âº±") return "6-";
  if (s === "6Âº∑") return "6+";
  return s;
}

function fitToEvent(detail){
  const parsed = parseJmaCoordinateFull(detail?.Body?.Earthquake?.Hypocenter?.Area?.Coordinate || "");
  const epiLatLng = parsed ? L.latLng(parsed.lat, parsed.lon) : null;

  const boundsStations = quakeLayer.getBounds();
  let finalBounds = null;

  if (boundsStations && boundsStations.isValid()) {
    finalBounds = boundsStations;
    if (epiLatLng) finalBounds.extend(epiLatLng);
    finalBounds = enforceMinBounds(finalBounds, 80); // 80 km min
  } else if (epiLatLng) {
    finalBounds = enforceMinBounds(L.latLngBounds(epiLatLng, epiLatLng), 80);
  }

  if (!finalBounds) return;

  map.fitBounds(finalBounds, {
    padding: [80, 80],
    animate: true,
    duration: 0.35
  });
}

function enforceMinBounds(bounds, minKm = 80){
  if (!bounds || !bounds.isValid()) return bounds;

  const c = bounds.getCenter();
  const dLat = minKm / 111;
  const cosLat = Math.cos((c.lat * Math.PI) / 180);
  const dLon = minKm / (111 * Math.max(0.2, cosLat));

  const minBounds = L.latLngBounds(
    [c.lat - dLat, c.lng - dLon],
    [c.lat + dLat, c.lng + dLon]
  );

  return bounds.extend(minBounds);
}

let lastDetail = null; // on garde le dernier JSON d√©tail cliqu√©

function setActiveTab(tabName){
  // boutons
  document.getElementById("tabBtnMap").classList.toggle("active", tabName === "map");
  document.getElementById("tabBtnCities").classList.toggle("active", tabName === "cities");

  // pages
  document.getElementById("tabMap").classList.toggle("active", tabName === "map");
  document.getElementById("tabCities").classList.toggle("active", tabName === "cities");

  // Leaflet doit recalculer quand on r√©-affiche la carte
  if (tabName === "map") {
    setTimeout(() => map.invalidateSize(), 50);
  }
}

function intensityOrder(x){
  const v = String(x || "").trim();
  const order = {"7":9,"6+":8,"6-":7,"5+":6,"5-":5,"4":4,"3":3,"2":2,"1":1};
  return order[v] || 0;
}

function buildPrefectureGroups(detail){
  const prefs = detail?.Body?.Intensity?.Observation?.Pref || [];
  const groups = [];

  for (const pref of prefs) {
    const prefJP = pref?.Name || "";
    const prefEN = pref?.enName || "";
    const prefMax = String(pref?.MaxInt || "").trim() || "?";

    const cities = [];
    for (const area of (pref.Area || [])) {
      for (const city of (area.City || [])) {
        const cInt = String(city?.MaxInt || "").trim();
        if (!cInt || cInt === "0" || cInt === "?") continue;

        cities.push({
          jp: city?.Name || "",
          en: city?.enName || "",
          int: cInt
        });
      }
    }

    if (cities.length === 0) continue;

    cities.sort((a,b) => intensityOrder(b.int) - intensityOrder(a.int) || a.jp.localeCompare(b.jp));
    groups.push({ prefJP, prefEN, maxInt: prefMax, cities });
  }

  groups.sort((a,b) => intensityOrder(b.maxInt) - intensityOrder(a.maxInt) || a.prefJP.localeCompare(b.prefJP));
  return groups;
}

function renderCitiesTab(detail){
  const summaryEl = document.getElementById("citiesSummary");
  const gridEl = document.getElementById("citiesGrid");

  if (!detail) {
    summaryEl.textContent = "Clique un s√©isme pour voir les villes touch√©es.";
    gridEl.innerHTML = "";
    return;
  }

  const groups = buildPrefectureGroups(detail);

  let totalCities = 0;
  for (const g of groups) totalCities += g.cities.length;

  const maxAll = String(detail?.Body?.Intensity?.Observation?.MaxInt || "").trim() || (groups[0]?.maxInt || "?");

  summaryEl.innerHTML = `
    <span class="badge">Pr√©fectures: ${groups.length}</span>
    <span class="badge">Villes: ${totalCities}</span>
    <span class="badge">Max: ${maxAll}</span>
  `;

  gridEl.innerHTML = groups.map(g => `
    <div class="prefCard">
      <div class="prefHeader">
        <div class="prefName">${g.prefJP}${g.prefEN ? ` <span class="muted">(${g.prefEN})</span>` : ""}</div>
        <div class="prefMeta">Max ${g.maxInt}</div>
      </div>

      ${g.cities.map(c => `
        <div class="cityRow">
          <div class="cityLeft">${c.jp}${c.en ? ` <span class="muted">(${c.en})</span>` : ""}</div>
          <div class="cityRight">Int ${c.int}</div>
        </div>
      `).join("")}
    </div>
  `).join("");
}

function epicenterIcon(){
  return L.divIcon({
    className: "epiWrap",
    iconSize: [18,18],
    iconAnchor: [9,9],
    html: `<div class="epiMarker"></div>`
  });
}

function fitBoundsWithMinKm(bounds, minKm = 80){
  if (!bounds || !bounds.isValid()) return;

  // centre actuel de la zone
  const c = bounds.getCenter();

  // approx: 1 degr√© latitude = 111 km
  const dLat = minKm / 111;

  // longitude d√©pend de la latitude
  const cosLat = Math.cos((c.lat * Math.PI) / 180);
  const dLon = minKm / (111 * Math.max(0.2, cosLat)); // √©vite divisions bizarres

  const minBounds = L.latLngBounds(
    [c.lat - dLat, c.lng - dLon],
    [c.lat + dLat, c.lng + dLon]
  );

  // on prend l'union: si la vraie zone est petite, minBounds gagne
  const finalBounds = bounds.extend(minBounds);

  map.fitBounds(finalBounds, { padding: [80, 80] });
}

function renderSelectedInfo(ev, detail){
  const selectedEl = document.getElementById("selected");

  const regionJP =
    detail?.Body?.Earthquake?.Hypocenter?.Area?.Name ||
    ev?.region ||
    "-";

  const regionEN =
    detail?.Body?.Earthquake?.Hypocenter?.Area?.enName ||
    ev?.regionEn ||
    "";

  const timeISO =
    detail?.Body?.Earthquake?.OriginTime ||
    ev?.time ||
    "";

  const timeText = (() => {
    try {
      const d = new Date(timeISO);
      return d.toLocaleString(undefined, {
        day: "2-digit",
        month: "short",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return timeISO;
    }
  })();

  const magnitude =
    detail?.Body?.Earthquake?.Magnitude ||
    ev?.magnitude ||
    "?";

  const maxInt =
    detail?.Body?.Intensity?.Observation?.MaxInt ||
    ev?.maxIntensity ||
    "?";

  const coordStr = detail?.Body?.Earthquake?.Hypocenter?.Area?.Coordinate || "";
  const parsed = parseJmaCoordinateFull(coordStr);
  let depthTextJP = "?";
  let depthEnSuffix = ""; // ajout√© seulement si shallow

  if (parsed?.depthKm != null && Number.isFinite(parsed.depthKm)) {
    const d = Math.round(parsed.depthKm);

  if (d <= 0) {
    depthTextJP = "„Åî„ÅèÊµÖ„ÅÑ";
    depthEnSuffix = " (Very shallow)";
  } else {
    depthTextJP = `${d} km`;
    depthEnSuffix = "";
  }
}

  const maxColor = intensityColor(normalizeIntensity(maxInt));

  const tsunamiJP =
    detail?.Body?.Comments?.ForecastComment?.Text ||
    detail?.Body?.Comments?.VarComment?.Text ||
    detail?.Body?.Comments?.FreeFormComment?.Text ||
    "";

  const tsunamiEN =
    detail?.Body?.Comments?.ForecastComment?.enText ||
    detail?.Body?.Comments?.VarComment?.enText ||
    detail?.Body?.Comments?.FreeFormComment?.enText ||
    "";

  // üü¢ Nouvelle info bar (remplace selBadges)
  const statsHtml = `
  <div class="metricsLine">

    <div class="metric">
      <div class="jp">M ${magnitude}</div>
      <div class="en">Magnitude</div>
    </div>

    <span class="sep">„Éª&nbsp;</span>

    <div class="metric metricMax">
      <div class="jp">
        <span class="intDot" style="background:${maxColor}"></span>
        ÊúÄÂ§ßÈúáÂ∫¶ ${maxInt}
      </div>
      <div class="en">Max intensity</div>
    </div>

   <span class="sep">„Éª&nbsp;</span>

    <div class="metric">
      <div class="jp">ÈúáÊ∫ê„ÅÆÊ∑±„Åï ${depthTextJP}</div>
      <div class="en">Depth${depthEnSuffix}</div>
    </div>

    <span class="sep">„Éª&nbsp;</span>

    <div class="metric">
      <div class="jp">Ë¶≥Ê∏¨ÁÇπÊï∞ ${countStations(detail)}</div>
      <div class="en">Stations</div>
    </div>
  </div>
`;

  selectedEl.innerHTML = `
    <div class="selTitle">${regionJP}</div>
    ${regionEN ? `<div class="selSub">${regionEN}</div>` : ""}
    <div class="selMeta">${timeText}</div>

    ${statsHtml}

    ${tsunamiJP || tsunamiEN ? `
      <div class="selTsunamiLong">
        <div><b>Ê¥•Ê≥¢</b>: ${tsunamiJP || "-"}</div>
        ${tsunamiEN ? `<div style="margin-top:4px;color:#9aa1b3"><b>Tsunami</b>: ${tsunamiEN}</div>` : ""}
      </div>
    ` : ""}
  `;
}


async function selectEvent(ev, div){
  selectedId = ev.id;

  updateSelectionUI();
  if (div) div.classList.add("selected");

  const selectedEl = document.getElementById("selected");
  selectedEl.innerHTML =
    "<b>S√©isme s√©lectionn√©:</b><br>" +
    (ev.region || ev.title || "") +
    "<br><span style='font-size:12px;color:#aaa;word-break:break-all'>" +
    ev.detailUrl +
    "</span>";

  setLayerDimmed(true);

  try{
    const detail = await getDetail(ev.detailUrl);

    quakeLayer.clearLayers();
    showStations(detail);
    showEpicenter(detail);
    fitToEvent(detail);

    lastDetail = detail;
    renderCitiesTab(lastDetail);
    renderSelectedInfo(ev, detail);
  } catch(err){
    selectedEl.innerHTML +=
      "<br><span style='font-size:12px;color:#FF7C7C'>Erreur detail: " + err.message + "</span>";
    console.error(err);
  } finally {
    setLayerDimmed(false);
  }
}

async function main(){
  const listEl = document.getElementById("list");

  try{
    const res = await fetch("./events.json", { cache: "no-store" });
    if(!res.ok) throw new Error("events.json introuvable (HTTP " + res.status + ")");

    const data = await res.json();
    const events = data.events || [];

    if(events.length === 0){
      document.getElementById("selected").textContent = "Aucun s√©isme trouv√©.";
      listEl.innerHTML = "Liste vide.";
      return;
    }

    // s√©lection par d√©faut = premier
    if(!selectedId) selectedId = events[0].id;

    listEl.innerHTML = "";

    let defaultDiv = null;
    let defaultEvent = events[0];

    events.forEach(ev => {
      const div = document.createElement("div");
      div.className = "item" + (ev.id === selectedId ? " selected" : "");

	  div.innerHTML = `
  <div class="cardRow1">
    <span class="dotInt" style="background:${intensityColor(ev.maxIntensity)}"></span>
    <span class="badge">M ${ev.magnitude ?? "?"}</span>
    <span class="badge">Max ${ev.maxIntensity || "?"}</span>
  </div>

  <div class="cardRow2">
    ${fmtShort(ev.time)}
  </div>

  <div class="cardRow3">
  	${ev.region || "-"}
  	${ev.regionEn ? `<span class="regionEn">(${ev.regionEn})</span>` : ""}
  </div>
`;

      div.onclick = () => selectEvent(ev, div);

      listEl.appendChild(div);

      if (ev.id === selectedId) {
        defaultDiv = div;
        defaultEvent = ev;
      }
    });

    // charge automatiquement le s√©isme s√©lectionn√© au d√©marrage
    await selectEvent(defaultEvent, defaultDiv);

  } catch(e){
    document.getElementById("selected").textContent = "Erreur: " + e.message;
    listEl.innerHTML = "";
    console.error(e);
  }
}


main();
</script>
</body>
</html>
